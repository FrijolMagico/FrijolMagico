-- 013_backfill_evento_edicion_participante.sql
-- Propósito: Poblar la tabla `evento_edicion_participante` a partir de los registros
-- en `participante_exposicion` y `participante_actividad` cuando falten.
--
-- Notas:
-- - Idempotente: usa ON CONFLICT DO NOTHING sobre la restricción UNIQUE (artista_id, evento_edicion_id).
-- - Estado derivado por pareja (evento_edicion_id, artista_id):
--     * 'completado' si alguna fila hija tiene estado = 'completado'
--     * 'cancelado' si alguna fila hija tiene estado IN ('cancelado','desistido','ausente')
--     * 'activo' en los demás casos
-- - Se usa MIN(created_at) como created_at representativa y CURRENT_TIMESTAMP como updated_at

BEGIN;

INSERT INTO evento_edicion_participante (
  evento_edicion_id,
  artista_id,
  estado,
  notas,
  created_at,
  updated_at
)
SELECT
  combined.evento_edicion_id,
  combined.artista_id,
  CASE
    WHEN MAX(CASE WHEN combined.estado = 'completado' THEN 1 ELSE 0 END) = 1 THEN 'completado'
    WHEN MAX(CASE WHEN combined.estado IN ('cancelado','desistido','ausente') THEN 1 ELSE 0 END) = 1 THEN 'cancelado'
    ELSE 'activo'
  END AS estado,
  NULL AS notas,
  MIN(combined.created_at) AS created_at,
  CURRENT_TIMESTAMP AS updated_at
FROM (
  SELECT evento_edicion_id, artista_id, estado, created_at FROM participante_exposicion
  UNION ALL
  SELECT evento_edicion_id, artista_id, estado, created_at FROM participante_actividad
) combined
GROUP BY combined.evento_edicion_id, combined.artista_id
ON CONFLICT (artista_id, evento_edicion_id) DO NOTHING;

COMMIT;
